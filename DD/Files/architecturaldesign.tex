\subsection{Overview: High-level components and their interaction}
This chapter describes the system components both at the physical and logical level.
The main high level components of the system are the following:
\begin{itemize}
\item
\textbf{Database:} The database server which is responsible for the data storage and retrieval. It doesn’t implement any logic as it is used only for data storing purposes. This layer must guarantee that the ACID properties are respected.
\item
\textbf{Application server:}  The application server contains all the logic on the server side of the system. This layer implements RESTful APIs and is used for registrations, login, backup and restore purposes.
\item
\textbf{Mobile Application:} The application consists in the client side of the application. It is installed on the users’ devices and implements most of the logic of the system. 
For the account/backup purposes it communicates directly with the application server, while for all the other functions is standalone.
\end{itemize}
The components are structured in a three layer application, shown in the following figure.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{images/highlevelstructure}
\caption{High Level Structure}
\label{ref:highlevelstructure}
\end{figure}

\clearpage
\subsection{Component View}
\input{files/componentview}

\clearpage
\subsection{Deployment View}
This diagram purpose is to show the hardware components of our system and where the code is going to run.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{images/DeploymentDiagram}
\caption{Deployment Diagram}
\label{ref:deploymentdiagram}
\end{figure}

\clearpage
\subsection{Runtime View}

\clearpage
\subsection{Component Interfaces}

\clearpage
\subsection{Selected Architectural styles and patterns}
The following architectural styles have been used:
\begin{itemize}
\item
\textbf{Model-Control-View:} It is used for the main components of the system. It’s a really good choice of design that allows to keep clear the role of every component and that makes the system easier to deploy and maintain.
\item
\textbf{Client-Server:} This pattern is a good practice for a distributed system. It is used between the application server (client) queries the DB (server) and the application (client) communicates with the application server.
\item
\textbf{Service-oriented Architecture:} It is used by the system for the communication between the server and the user’s device (RESTful). The SOA allows to think at a higher level of abstraction, by looking at the component interfaces and not at their specific implementation. SOA style also improves modularity: by making service description, discovery and binding explicit, it is easier to build new plugins and test single modules independently.
\item
\textbf{Fat Client:} The fat client paradigm is implemented because the interaction between user’s device and the server hasn’t a central role in the system behavior . Having a fat client in our case is an advantage because most application logic is on the user’s device, which has sufficient computing power and is able to manage concurrency issue efficiently.
\end{itemize}
